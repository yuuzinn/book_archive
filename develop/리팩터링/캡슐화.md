### 캡슐화
데이터에 대한 접근을 함수로만 한정하는 것을 의미해요.

#### 캡슐화의 이점은 무엇일까?
- 데이터에 대한 접근을 한정함으로써 의도치 않은 변경을 예방해요. (전역변수/가변데이터)
- 데이터 입출력 시 추가로직을 쉽게 해요.
  - ex) 객체의 사본 제공
  - ex) 특정 입력 무시

### 레코드 캡슐화
레코드는 간단히 이야기하자면, 구조체라고도 해요. C언어에서도 나오는 키워드.
- Java Script
    - 모든 Object는 그 자체로 레코드로 사용이 가능해요.
    - HashMap 등으로도 레코드로 사용이 가능해요.

개인적인 생각이지만, Java에서는 클래스를 의미하는 것 같다.

레코드 캡슐화의 결과는 결국 레코드를 클래스로 만드는 것이에요.

레코드는 데이터의 집합이며, 캡슐화는 이 데이터들에 대한 입출력 함수를 만드는 것이에요. 따라서 데이터와 입출력 함수가 만나게 되면 클래스가 되는 것이에요.

### 컬렉션 캡슐화
Java에서는 Collection이라 함은, List, Set, Map 등의 Type 이 존재해요. Kotlin 에서도 마찬가지로요.

#### 이러한 Collection이 레코드와의 차이점은 무엇일까?
Getter / Setter를 설정해도 예상치 못한 변경이 일어날 수 있어요. 사실은 모든 Reference Type에 해당이 되어요.

클래스 추출하기 : 하나의 클래스를 둘로 쪼개기

클래스는 반드시 명확하게 추상화하고, 소수의 주어진 역할만 처리해야 해요.

#### 언제 추출할까?
특히 클래스의 특정 데이터와 특정 메서드들을 두 분류로 나눌 수 있다면 추출하도록 해요.

### 클래스 인라인 하기 (추출 반대)

두 클래스를 하나로 합해요.

#### 언제 인라인할까?
- 특정 클래스에 남은 역할이 거의 없을 때
- 두 클래스의 기능을 재분배 하고 싶을 때
  - 합하고 역할 재분배 후 나누기

### 위임 숨기기

- 위임이란?
  - 객체가 다른 객체를 포함하는 관계예요. (자의적 정의)

```java
  Long managerId = aPerson.department.manager.getId(); // 1단계.2단계.3단계
```
- 위임을 숨긴다
- 위임관계인 두 객체를 숨기고, 대신 캡슐화된 메서드로 접근해요.
```java
Long managerId = aPerson.getManagerId();

Class Person {
    ...
    public Long getManagerId() {
        return this.department.manager.getId();
    }
}
```

#### 그렇다면, 이점은 무엇일까요?
문제인건, 3단계의 값을 꺼내오기 위해 1단계, 2단계, 3단계 구조를 모든 부분 알아야 한다는 거예요. 이렇게 된다면 더 많은 코드가 타 코드의 구조에 의존적이 될 수밖에 없다는 것이지요.

만약 구조가 바뀐다면 어떻게 될까요? 예를 들어, Person - Manager 관계로 바뀌게 된다면
```java
aPerson.department.manager.getId()
```
사용되어 있는 모든 부분들을 바꿔줘야 한다는 것이에요. 하지만 캡슐화가 되어 있다면 해당 메서드 하나만 바꿔주면 되기 때문에 이러한 점이 이점이라 볼 수 있는 것이지요.

### 중개자 제거하기 (숨기기의 반대)

#### 왜 제거할까요?
getManagerId()와 같은 메서드가 지나치게 많아진다면 Person은 단순히 중개자로만 전락하게 되어요. Person의 정보만 가지고 있어야 할 것들을 ManagerId(), Age(), DepartmentId()... 등등 정보들이 한 클래스 안에 한가득히 모여 있다는 것이에요.
