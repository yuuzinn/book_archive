### Entity
책에서는 DDD(Domain-Driven-Design)를 기반으로 도메인 클래스를 정의한다고 설명해 주지만 이 부분에 대해서는 무지하기에 넘어가요. 나중에 DDD관련하여 볼 일이 생긴다면, 에릭 에반스의 『도메인 주도 설계 : 소프트웨어의 복잡성을 다루는 지혜』를 참고해요.
### Template의 지원
위에서 도메인 클래스를 하나 정의 후 여러 조건들을 따져 DB, 추상화 수준을 정해요. Spring 생태계에선 이렇게 정하는 작업에선 보통 Template나 Repository 중 하나를 정해요.

일관된 추상화를 제공하기 위해 Spring 에서 다양한 데이터 소스에 Operations Type의 Interface를 정의해요. NoSQL로는 MongoOperations, RedisOperations... 등등 사용해요. Template는 일종의 SPI (서비스 제공 인터페이스)예요. 바로 사용할 수 있어 유용하지만, 매번 반복하는 단계를 거쳐요.
일반적인 패턴의 데이터 액세스는 Repository가 더 좋은 옵션이 되어요.

### Repository
Spring Data가 Repository 인터페이스를 정의,이로부터 모든 유형의 Spring Data Repository 인터페이스가 파생되어요. JPARepository에선 MongoDB 기능을 더 사용하는 MongoRepository, CrudRepository에선 용도가 더 다양한 Repository들이 파생되어요. 이 인터페이스에선 흔히 사용하던 findById(), findAll(), count(), delete(), save().. 등처럼 다양한 함수들을 제공해요.
또한 Repository는 '설정보다 관습'을 사용한 Query 뿐만 아니라 Native Query도 지원해요. 복잡한 쿼리들은 Native 형식의 쿼리로 구축하고, 단순하고 반복적인 쿼리들은 위의 함수들로 생산성이 좋고, 속도가 빠른 개발이 가능해요.

Template의 지원을 통해 DB 작업은 하위 수준의 API를 제공해요. 반복적이고 코드의 복잡성이 늘어나 생산성이 줄어들 수 있고, 마찰이 일어날 수 있어요. 때문에 이러한 단점들을 극복할 수 있으며 재사용성을 찾는다면 Repository를 사용하는 것이 더 좋은 선택이에요.
```java
Connection con = null;
ResultSet rs = null;
PreparedStatement psmt = null;

String url = "...";
String id = "...";
String pw = "...";
// ... JDBC 연결
try {
    String sql = "INSERT INTO ...";
//   ... 필드값
    psmt = con.prepareStatement(sql);
//   ... 필드값 부여
    } catch (Exception e) {
    ... 생략
```
기존에는 이런 식으로 JDBC를 통해서 DB와 연결하여 통신하고, 쿼리를 직접 사용하고, 필드값을 생성해 직접 부여해줘요. Spring JPA를 사용해 JPA Repository를 통해서는 이를 Repository 기반 작업으로 대체해 리팩터링할 수 있어요.
```java
// .. 값 넣기 생략 (Set, Builder..)
testRepository.save(test);
```
값을 넣어준 후 위의 함수 save() 메서드를 이용해 쿼리를 자동으로 보내 DB에 저장해요. 물론 JPA 에서는 설정을 통해 미리 DB와 연동을 끝마친 상태이지만, 여기서 말하고자 하는 것은 생산성과 재사용성, 코드의 복잡성은 줄어들고 인터페이스의 기능을 완벽하게 소화한다는 점이에요. MySQL을 쓰던, Oracle을 쓰던 쿼리는 조금씩 다르지만, 겉보기 동작은 같듯이 말이지요.
### 테스트
단위 테스트의 장점은 개발, 배포 시, 특히나 개발 시기에 빠르게 버그를 찾아낼 수 있어요. 그리고 복잡한 코드일 수록 잘게 나뉘어진 단위 테스트는 어디가 문제인지 더더욱이 빠르게 찾을 수 있어요. 비용도 가장 적기에 큰 장점이라 말할 수 있어요. 아래의 내용부터는 책을 읽으며 배우며 들었던 내용들을 추려서 작성합니다.

통합 테스트는 하나의 기능 단위로 테스트하기 때문에 해당 동작에 대해서 검증할 수 있어요. 장점으로는 단위 테스트에서 발견하기 어려운 버그를 찾아낼 수 있다는 점이에요. 그러나 단점으로는 단위 테스트에 비해서 코드의 복잡도나 많은 코드가 존재하기 때문에 어디서 문제가 발생한지 찾기 어려워요.

테스트에는 크게 두 파가 존재해요. 고전파와 런던파예요.
### 고전파
- 테스트 주도 개발에 원론적으로 접근하기
- 의존성은 공유하는 의존성들을 제외하고, 전부 실제 객체를 사용해요.
- 격리 주체는 단위테스트로 진행하며, 검증 단위는 단일 클래스나 클래스 세트로 진행해요.
### 런던파
- 격리된 방식으로 처리하기
- 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면, 모두 테스트 대역으로 교체해요.
- 불변 의존성 외의 모든 의존성은 Mock(테스트)으로 대체해요.
- 격리 주체는 단위(하나의 클래스),검증 단위는 단일 클래스로 진행해요.
## 좋은 테스트 4대 특성
### 회귀 방지
회귀방지는 버그를 방지할 수 있어야 한다는 뜻이에요. 코드를 수정하고 버그가 있었는데, 테스트가 통과하면 안 돼요. 기능이 새로 구현될 때 자신이 의도한 대로 동작하는지 테스트 코드를 통해 검증해야 해요. 회귀 방지를 높이려면 테스트가 가능한 많은 코드를 실행하는 것을 목표로 해야해요.
### 리팩터링 내성
리팩터링 내성은 테스트를 실패로 바꾸지 않고, 기본 Application 코드를 리팩터링 할 수 있는지에 대한 척도예요. 리팩터링을 한 후에 기능은 정상이나 테스트가 실패하면 거짓 양성이라 해요. 반대로, 기능이 비정상인데 테스트가 성공하면 거짓 음성이라 해요.

거짓 양성은 테스트에 크게 영향을 끼쳐요.

- 테스트가 타당한 이유 없이 실패하면 문제에 대응하는 능력과 의지 희석
- 테스트를 시간이 지남에 따라 신경쓰지 않게 됨을 의미
- 테스트 스위트에 대한 신뢰가 떨어져 리팩터링 감소
- 테스트에 대한 신뢰성 부족을 의미

기능이 비정상인데 테스트가 성공하게 된다면, 테스트에 대해 신뢰성이 떨어지게 돼요. 그만큼 허용폭이 넓다는 의미이고, 테스트는 무의미해지는 것이지요.
기능을 변경, 추가함에 따라 테스트 코드를 이에 맞춰 변경해야 한다면 정확도와 신뢰성은 올라가나 테스트가 깨지기 쉬워요. 하지만 기능 변경을 했음에도 (심하게는 위의 거짓음성처럼) 테스트코드가 정상적으로 흘러가게 된다면 의심을 해보거나 내성이 생김을 의미해요. 따라서 이 둘의 적절한 수준을 찾는 것이 중요해요.
### 빠른 피드백, 유지 보수
느린 테스트는 피드백을 느리게 하며, 잠재적으로 버그를 늦게 눈에 띄게 해 버그 수정 비용이 증가해요. 심지어 오래 걸리는 테스트는 자주 실행하지 못하기 때문에 잘못된 방향으로 감으로써 시간을 더 많이 소비하게 돼요.