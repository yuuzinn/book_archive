해당 책을 보고 정리함을 출처로 남깁니다.
### Spring boot starter
Spring boot starter Dependency는 Spring boot에서 아주 핵심적인 의존성이에요.

기존에 Legacy Project의 경우 boot가 아닌 Spring으로 되어 있어서 yml 설정으로 하나씩 연결해주어야만 해요. 당연히 Spring boot starter는 없어요.

그렇다면 이 Spring boot starter의 큰 특징은 무엇이고, 무엇이 담겨 있나요?

- 의존성의 관리가 단순해져요.
- 배포하는 게 단순해져요.
- 자동 설정의 이점이 있어요.

### 의존성의 관리가 단순해진다.
의존성들을 관리하는 데에 있어서 의존성이 엇갈려 꼬일 수가 있어요. 버전의 차이라던지? 어떤 의존성을 사용할지?
겹치게 된다면 말이에요. boot 에서는 의존성을 쉽게 관리함으로써, 버전의 경우도 개발자가 작성해 둔다면 해당 버전으로 적용이 되어 관리하기 수월해져요.

실제로 의존성이 어떻게 들어가 있는지 확인해보면, 의존성이 겹치더라도 개발자가 지정해 놓은 설정으로 적용되는 모습을 확인할 수 있어요.

### 배포하는 것이 단순해진다.
이전에는 배포하는 데에 있어 귀찮고, 복잡했어요.
Application 서버를 설정하고, DB driver, Connection - pool, ... Jar 파일을 통해서 손쉽게 배포할 수 있게 되었어요. (War 파일의 경우는 별도의 웹서버(WAS)가 필요해요.)
java -jar projectName.jar
### 자동 설정의 이점
자동 설정의 이점은 무엇인가요? 흔히 개발할 때 사용했던 properties에서도 확인할 수 있어요.
기본 port는 몇으로 할 건지? 아니면 JPA 설정은 어떻게 지정해줄 건지? 등등... 서로 다른 설정들이지만, 어느정도 정해진 패턴들이 존재해요.
이렇게 통계로 내어 보니 같은 설정을 쓰는 프로젝트들이 겹치는 것이 7-80% 정도 된다는 것이에요.

새 프로젝트를 만들어서 설정하자니, 이전과 같은 설정들을 똑같이 지정하는 게 참 귀찮아요.

그래서 Spring boot starter는 default 값으로 설정들의 값들을 매겨 사용할 수 있게 해줘요. 이것 또한 엄청난 혁명이라 말할 수 있지요.
그리고 이러한 방식으로 코드에 접근하는 방식을 `설정보다 관습(Convention over Configuration)라 해요.`
거의 마법이라 해도 무방할 정도...

### Gradle VS Maven
- Gradle
  - 대규모 프로젝트의 경우 Gradle이 비교적 빨라요.
  - 대규모 프로젝트가 아니더라도 Gradle이 더 빠른 편이에요.
  - 가독성 면에서 우세하다. 스크립트의 길이가 짧은 편이에요.
  - 버전의 경우 적어두지 않아도 Spring boot 버전에 따라서 적용돼요.
  - Gradle은 코드에 조금 더 중점을 두고 설정을 관리해요.
  - 요즘은 Gradle로 넘어가는 추세예요.
    - Groovy라는 언어로 관리하는데, JVM에서 실행되는 스크립트 언어이다. Kotlin으로도 작성할 수 있어요.

- Maven
  - 대규모 프로젝트의 경우 비교적 느려요.
  - 가독성 면에서 조금 부족하다. 스크립트의 길이가 긴 편이에요.
    - 하지만 URL이나 다른 정보들을 추가함으로써 조금 더 자세하게 설정할 수 있게 돼요.
  - Maven은 설정에 조금 더 특화(?)되어 있다고 봐도 무방해요.

### Spring boot main() 함수
보통 Spring boot 프로젝트를 실행하다 보면, main 함수를 통해서 프로젝트가 실행된다는 것은 모두 알고 있을 것이에요.

하지만 Spring Legacy 프로젝트들을 보면 main 함수가 없어요. 그러면 어떻게 실행시키나요?

위에서 말했듯이 War 파일로 되어 있는데, 별도의 Web Server 가 필요하다 말했어요. Tomcat Server를 띄워 놓고 War 파일인 해당 프로젝트를 가져와서 사용하게 되는 방식이에요.

부트에서는 반드시 main 클래스에 @SpringBootApplication 어노테이션과 main 함수에 SpringApplication.run(TestApplication.class, args)가 있어야만 해요.

### REST API
그 이전에 `모노`와 `스테레오`의 차이점을 간단하게 알아봐요.
- 모노 : 간단하게 숫자 하나 라는 의미와 같아요.
- 스테레오 : 두 개예요.

### API ?
모놀리식 Application은 말 그대로 하나의 서버 Application이에요. 실제 서비스를 운영하고 있는 곳에선 하나의 서버만을 운영하는 곳은 많지는 않을 것이에요.

MSA 환경에서 운영하고 있는 곳과 모놀리식 환경의 서버는 각각의 차이점이 존재해요.

MSA 환경의 경우 도메인 별로 서로 나뉘어서 각자 기능을 수행하고 한 곳에 모이는 반면, 모놀리식은 위와 같아요.
이렇게 간단하게 둘만 두고 비교해보았을 때, 유연함과 성능은 누가 더 우세할까요?

유연함으로는 도메인 별로 분리되어 있는 MSA 환경, 성능으로는 모놀리식의 환경이 더 우세해요.

#### 왜 그런가요?

간단해요. 한 곳이 장애가 난다면, 분리되어 있는 곳과 한 곳에 모두 모여 있는 곳 어느 곳이 더 유연할까요?

성능적으로 보았을 때는 MSA 환경의 경우 네트워크를 어쨌든 최소한 한 번은 타야 되기 때문에 비교적 느릴 수밖에 없어요.

### 진정한 REST API
우리가 항상 개발해 왔던 REST API는 응답값들에 대해선 보통 Json 형식으로 반환해주곤 해요.
예를 들자면, 아래와 같아요.
```json
{
  "id" : 30,
  "name" : "상훈",
  "age" : 27
}
```

하지만 진정한 REST API는 REST API를 창시한 분께서 말씀하시길, 해당 Resource 에 대한 Link (Hypermedia)를 적용해야 한다는 것이에요.
Hypermedia As The Engine Of Application State (HATEOAS)
(사실 이 부분은 잘 모르겠습니다.)
```json
{
  "id" : 30,
  "name" : "상훈",
  "age" : 27,
  "link" : {
    "href" : "http://localhost:8080/.../..."
  }
}
```
### @Value, 설정 참조
보통 @Value 어노테이션을 통해 yml이나 properties에서 참조해서 값을 가져오게 돼요. 하지만 Test 하기에는 불편함이 존재해요. 그래서 생성자를 통해 관리를 해주는 것도 하나의 방법이에요.

여기 부분은 조금 더 자세히 공부할 필요가 있어 보이니, 추후에 수정하여 더 작성할 예정이에요.

### 자동 설정 리포트
Spring boot 에서는 자동으로 Bean 들을 관리하고 올려 줘요. 사용자(개발자)는 boot에서 어떤 bean들을 올려 주는지 확인할 수 있어요.

왜 확인할 수 있게 만들었나요?

내가 예상한, Custom해서 올린 bean들이 있고, Spring boot 에서 기본적으로 올려주는 bean 들이 존재하는데
무엇이 겹쳐서 오류가 나는지 확인할 수도 있으며 이에 따라 대응이 가능하기 때문이에요.

positive matches, negative matches 로 확인이 가능해요. 여기서 이 positive/negative 용어의 뜻은
양수, 긍정 / 음수, 부정의 뜻을 가지고 있으나, 알아본 바로는 각각 매칭되는 항목 / 그렇지 않은 항목이라 되어 있어요.

단어 뜻 정도는 알아 두면 좋다 하여 기억하는 것이 좋을 것 같아요.

### 액추에이터
이 부분도 Value 부분과 마찬가지로 이해도가 많이 떨어지는 부분이에요. 하지만 배운 것을 토대로 작성해 보자면.

액추에이터는 실행 중인 Application 정보를 접근하고 노출할 수 있다는 것이에요.
해당 서버의 상태(Health)는 어떤지 확인할 수 있고, 정보(info)도 확인할 수 있고... 등등 여러 정보들이 포함되어 있어요.

이 정보들 중에서는 외부에 알려지면 안 되는 정보들도 당연히 존재해요. 예를 들어, 사용하는 Java version은 몇인지?
이러한 점들은 해커의 입장에선 너무나도 좋은 정보예요. Java 버전에 따라 취약한 점들이 존재하기 때문에 그 부분을 공격할 수 있기 때문이에요.

따라서 이런 중요한 정보들은 노출시키지 않는 것이 중요해요. 따로 properties에서 지정해서 보여줄 수도 있어요.